#location for the modules
from turtle import pos
import pandas as pd
import numpy as np
from nltk.corpus import wordnet
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from gensim.models import KeyedVectors
from wefe.datasets import (
    load_weat,
    fetch_eds,
    load_bingliu,
)

from wefe.query import Query

def find_x_most_similar(model, poswords=[], negwords=[], topn=100):
    """
    Find the topn most similar words to the vector generated bycomputing the cosine similarity between a simple mean of the wordsin poswords and negwords.
    Poswords and negwords are lists of strings.
    Poswords count positively, negwords count negatively.
    """
    data = model.most_similar(positive=poswords, negative=negwords, topn=topn)
    df = pd.DataFrame(data, columns=['word', 'similarity'])
    df['original_word'] = str(poswords) + '-' + str(negwords)
    return df


def round_coloums(df, decimals=2):
    """
    Round the values of a dataframe to the specified number of decimals.
    """
    
    for col in df.columns:
        #make sure the column is numeric/float
        if df[col].dtype in ['float64', 'int64']:
            df[col] = df[col].round(decimals)
    return df

def add_ranks(df):
    '''
    Adds 3 columns, 
        (1,2) rel_similarity_rank & similarity_rank
            The respective rank is based on mentioned similarity. i.e. the lowest (1) rel_similarity_rank has the highest rel_similarity.
        (3)relative_gain
            The diference between the similarity_rank and the rel_similarity_rank.  
    '''
    df = df.sort_values(by='similarity', ascending=False)
    #drop similarity_rank if it exists
    if 'similarity_rank' in df.columns:
        df.drop('similarity_rank', axis=1, inplace=True)
    df.insert(loc=0, column='similarity_rank', value=range(1, len(df)+1))
    df = df.sort_values(by='rel_similarity', ascending=False)
    #drop rel_similarity_rank if it exists
    if 'rel_similarity_rank' in df.columns:
        df.drop('rel_similarity_rank', axis=1, inplace=True)
    df.insert(loc=0, column='rel_similarity_rank', value=range(1, len(df)+1))
    df['relative_gain'] = df['similarity_rank'] - df['rel_similarity_rank']
    return df



def calulate_relative_similarity(df,model, word, words=10):
    '''
    Add a column with the relative similarity of the word to the other words in the model
    '''
    df['rel_similarity'] = df.word.apply(lambda x: model.relative_cosine_similarity(x, word, words))
    return df



def display_pca_scatterplot(model, words=None, sample=0):
    if words == None:
        if sample > 0:
            words = np.random.choice(list(model.vocab.keys()), sample)
        else:
            words = [ word for word in model.vocab ]
        
    word_vectors = np.array([model[w] for w in words])

    twodim = PCA().fit_transform(word_vectors)[:,:2]
    
    plt.figure(figsize=(6,6))
    plt.scatter(twodim[:,0], twodim[:,1], edgecolors='k', c='r')
    for word, (x,y) in zip(words, twodim):
        plt.text(x+0.05, y+0.05, word)

def antonyms_for(word):
    antonyms = set()
    for ss in wordnet.synsets(word):
        for lemma in ss.lemmas():
            any_pos_antonyms = [ antonym.name() for antonym in lemma.antonyms() ]
            for antonym in any_pos_antonyms:
                antonym_synsets = wordnet.synsets(antonym)
                if wordnet.ADJ not in [ ss.pos() for ss in antonym_synsets ]:
                    continue
                antonyms.add(antonym)
    return antonyms


def plot_word_vectors(df):
    '''
    plot the x and y coordinates
    '''
    df.reset_index(drop=True, inplace=True)
    #plot the coordinates
    plt.scatter(df.x, df.y)
    #add the words as labels
    for i, txt in enumerate(df.word):
        plt.annotate(txt, (df.x[i], df.y[i]))
    return plt.show()

def antonyms_for(word):
    antonyms = set()
    for ss in wordnet.synsets(word):
        for lemma in ss.lemmas():
            any_pos_antonyms = [ antonym.name() for antonym in lemma.antonyms() ]
            for antonym in any_pos_antonyms:
                antonym_synsets = wordnet.synsets(antonym)
                if wordnet.ADJ not in [ ss.pos() for ss in antonym_synsets ]:
                    continue
                antonyms.add(antonym)
    return list(antonyms)

def add_low_case_column(df):
    df['low_case'] = df['word'].str.lower()
    return df

def remove_antonyms_from_df(df,antonyms):
    df = add_low_case_column(df)
    df = df[~df.low_case.isin(antonyms)]
    df.drop('low_case', axis=1, inplace=True)
    return df 


def cut_off_df(df,cut_off_value):
    df = df[df.rel_similarity_rank <= cut_off_value]
    df = df[df.similarity_rank <= cut_off_value]
    return df

def gen_similar_words_df(model, poswords=[], negwords=[], topn=100, num_of_rel_words=10, cut_off_value=100):
    '''
    NOT COMPLETE - SINGLE WORD USAGE ONLY (either poswords or negwords)

    - Generates a dataframe with the topn most similar words to the vector generated bycomputing the cosine similarity
    between a simple mean of the wordsin poswords and negwords using a gensim KeyedVectors model.
    - Removes antonyms from the list
    - Calculates the cosine similarity, relative cosine similarity of the words to the vector
    Ranks and removes the words that are not in the nth "cut_of_value" of EITHER similarity.
    '''

    df = find_x_most_similar(model,poswords=poswords,negwords=negwords,topn=topn)
    antonyms = antonyms_for(poswords[0])
    df = remove_antonyms_from_df(df,antonyms)
    df = calulate_relative_similarity(df,model,poswords[0], words=num_of_rel_words)
    df = add_ranks(df)
    df = cut_off_df(df,cut_off_value) 
    return df

def plot_PCA(df, model):
    '''
    plot the PCA of the words in the dataframe
    '''
    words = df.word.to_list()
    display_pca_scatterplot(model, words=words)

def append_dfs(df1, df2):
    '''
    Append two dataframes
    '''
    return df1.append(df2, ignore_index=True)

def check_if_word_in_model(word, model):
    #check if model keyedvector or full
    if isinstance(model, KeyedVectors):
        if word in model.key_to_index:
            return True
        else:
            return False
    try:
        model.wv.vocab[word]
        return True
    except KeyError:
        return False

def normalize(dataset):
    return pd.json_normalize(dataset)


def filter_datasets(model):
    list_in_model = []
    not_in_model = 0
    database_run_count = 0
    WEAT_wordsets = load_weat()
    RND_wordsets = fetch_eds()
    sentiments_wordsets = load_bingliu()
    WEAT_norm = normalize(WEAT_wordsets)
    RND_norm = normalize(RND_wordsets)
    sentiments_norm = normalize(sentiments_wordsets)
    datasets = [WEAT_norm, RND_norm, sentiments_norm]
    for dataset in datasets:
        database_run_count += 1
        for i in dataset:
            for j in dataset[i]:
                for k in j:
                    if isinstance(k, str):   
                        if check_if_word_in_model(k.lower(), model):
                            list_in_model.append("{}{}{}".format(i,":", k.lower()))
                        else:
                            not_in_model += 1
                    else:
                        print("{}{}{} is not a string".format(database_run_count, i, k))
                        pass
    list_in_model = pd.DataFrame(list_in_model, columns=["to_split"])
    list_in_model = list_in_model["to_split"].str.split(":", expand=True)
    list_in_model.columns = ["category", "word"]
    print("{} words not in model".format(not_in_model))
    return list_in_model

def redefine_categories(df):
    flowers = df[df.category == 'flowers']['word'].to_list()
    insects = df[df.category == 'insects']['word'].to_list()
    pleasant_5 = df[df.category == 'pleasant_5']['word'].to_list()
    unpleasant_5 = df[df.category == 'unpleasant_5']['word'].to_list()
    instruments = df[df.category == 'instruments']['word'].to_list()
    weapons = df[df.category == 'weapons']['word'].to_list()
    european_american_names_5 = df[df.category == 'european_american_names_5']['word'].to_list()
    african_american_names_5 = df[df.category == 'african_american_names_5']['word'].to_list()
    european_american_names_7 = df[df.category == 'european_american_names_7']['word'].to_list()
    african_american_names_7 = df[df.category == 'african_american_names_7']['word'].to_list()
    pleasant_9 = df[df.category == 'pleasant_9']['word'].to_list()
    unpleasant_9 = df[df.category == 'unpleasant_9']['word'].to_list()
    male_names = df[df.category == 'male_names']['word'].to_list()
    female_names = df[df.category == 'female_names']['word'].to_list()
    career = df[df.category == 'career']['word'].to_list()
    family = df[df.category == 'family']['word'].to_list()
    math = df[df.category == 'math']['word'].to_list()
    arts = df[df.category == 'arts']['word'].to_list()
    male_terms = df[df.category == 'male_terms']['word'].to_list()
    female_terms = df[df.category == 'female_terms']['word'].to_list()
    science = df[df.category == 'science']['word'].to_list()
    arts_2 = df[df.category == 'arts_2']['word'].to_list()
    male_terms_2 = df[df.category == 'male_terms_2']['word'].to_list()
    female_terms_2 = df[df.category == 'female_terms_2']['word'].to_list()
    mental_disease = df[df.category == 'mental_disease']['word'].to_list()
    physical_disease = df[df.category == 'physical_disease']['word'].to_list()
    temporary = df[df.category == 'temporary']['word'].to_list()
    permanent = df[df.category == 'permanent']['word'].to_list()
    young_people_names = df[df.category == 'young_people_names']['word'].to_list()
    old_people_names = df[df.category == 'old_people_names']['word'].to_list()
    adjectives_appearance = df[df.category == 'adjectives_appearance']['word'].to_list()
    adjectives_otherization = df[df.category == 'adjectives_otherization']['word'].to_list()
    adjectives_sensitive = df[df.category == 'adjectives_sensitive']['word'].to_list()
    names_asian = df[df.category == 'names_asian']['word'].to_list()
    names_black = df[df.category == 'names_black']['word'].to_list()
    names_chinese = df[df.category == 'names_chinese']['word'].to_list()
    names_hispanic = df[df.category == 'names_hispanic']['word'].to_list()
    names_russian = df[df.category == 'names_russian']['word'].to_list()
    names_white = df[df.category == 'names_white']['word'].to_list()
    words_christianity = df[df.category == 'words_christianity']['word'].to_list()
    words_islam = df[df.category == 'words_islam']['word'].to_list()
    words_terrorism = df[df.category == 'words_terrorism']['word'].to_list()
    male_occupations = df[df.category == 'male_occupations']['word'].to_list()
    female_occupations = df[df.category == 'female_occupations']['word'].to_list()
    occupations_white = df[df.category == 'occupations_white']['word'].to_list()
    occupations_black = df[df.category == 'occupations_black']['word'].to_list()
    occupations_asian = df[df.category == 'occupations_asian']['word'].to_list()
    occupations_hispanic = df[df.category == 'occupations_hispanic']['word'].to_list()
    adjectives_intelligence = df[df.category == 'adjectives_intelligence']['word'].to_list()
    positive_words = df[df.category == 'positive_words']['word'].to_list()
    negative_words = df[df.category == 'negative_words']['word'].to_list()
    return flowers,insects,pleasant_5,unpleasant_5,instruments,weapons,european_american_names_5,african_american_names_5,european_american_names_7,african_american_names_7,pleasant_9,unpleasant_9,male_names,female_names,career,family,math,arts,male_terms,female_terms,science,arts_2,male_terms_2,female_terms_2,mental_disease,physical_disease,temporary,permanent,young_people_names,old_people_names,adjectives_appearance,adjectives_otherization,adjectives_sensitive,names_asian,names_black,names_chinese,names_hispanic,names_russian,names_white,words_christianity,words_islam,words_terrorism,male_occupations,female_occupations,occupations_white,occupations_black,occupations_asian,occupations_hispanic,adjectives_intelligence,positive_words,negative_words

















def get_2d_coordinates(df, TSNE_model):
    """
    This function takes a dataframe and a TSNE model and returns the 2D coordinates of the words
    """
    # fit the model
    vectors = TSNE_model.fit_transform(df['vector'].values.tolist())
    
    for i in range(len(df)):
        df.loc[i, 'x'] = vectors[i][0]
        df.loc[i, 'y'] = vectors[i][1]
    return df

def add_vector_column(df,model):
    '''
    Add a column with the vector representation of the word from the model
    '''
    df['vector'] = df['word'].apply(lambda x: model[x])
    return df